Object subclass: #SADParser	instanceVariableNames: 'grammar semantics'	classVariableNames: ''	poolDictionaries: ''	category: 'SAD-Parser'!!SADParser methodsFor: 'parsing' stamp: 'jws 11/16/2025 16:12'!parse: aStringrule: aGrammarRuleName	| parseTree |	parseTree := self grammar 		matchStream: (OhmInputStream on: aString) 		startingFrom: aGrammarRuleName		failureAsException: true.	^self semantics value: parseTree.! !!SADParser methodsFor: 'accessing' stamp: 'jws 11/16/2025 16:12'!grammar	grammar == nil 		ifTrue: 			[grammar := OhmCompiler compileGrammarDefinition: self class serializedGrammar.			semantics := SADSemantics new.			grammar semanticAction: semantics].	^grammar! !!SADParser methodsFor: 'accessing' stamp: 'jws 11/16/2025 16:12'!semantics	^semantics! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SADParser class	instanceVariableNames: ''!!SADParser class methodsFor: 'parsing' stamp: 'jws 11/16/2025 16:10'!parse: aString	^self parse: aString rule: 'Program'! !!SADParser class methodsFor: 'parsing' stamp: 'jws 11/16/2025 16:10'!parse: aStringrule: aGrammarRuleName	^self new parse: aString rule: aGrammarRuleName! !!SADParser class methodsFor: 'accessing' stamp: 'jws 11/19/2025 18:54'!serializedGrammar	^'Sad { 	Program		= "sadness" Variables? Methods? "do" Statement    	Variables		= "reasons" Variable+        Variable		= identifier "isa" Type    	Type 		= "integer"		| "boolean"		| "string"    	Methods		= "sorrows" Method+    	Method		= Function		| Procedure  	Function		= "disfunction" identifier ParameterList "isa" Type MethodBody  	Procedure		= "sob" identifier ParameterList MethodBody    	ParameterList		= "(" (Variable ("," Variable)*)? ")"			MethodBody		= Variables? "do" Statement			Statement		= BlockStatement		| Assignment		| IOStatement		| IOWriteLineStatement		| IfThenElseStatement		| IfThenStatement		| WhileStatement		| ProcedureCall    	IfThenElseStatement		="if" Expression "then" Statement "else" Statement	IfThenStatement		="if" Expression "then" Statement    	WhileStatement		= "while" Expression "do" Statement    	ProcedureCall		= identifier ArgumentList        	FunctionCall		= identifier ArgumentList    	ArgumentList		= "(" (Expression ("," Expression)*)? ")"        	IOStatement		= "writeString" Expression		| "writeInteger" Expression		| "writeBoolean" Expression    	IOWriteLineStatement		= "writeNewLine"			Assignment		= identifier "<-" Expression    	BlockStatement		= ":-(" Statement+ ")-:"    	Expression		= BinaryExpression		| UnaryExpression		| FunctionCall		| GroupExpression		| VariableReference		| literalString		| literalBoolean		| literalInteger		| identifier        	GroupExpression		= "(" Expression ")"    	BinaryExpression		= Expression BinaryOp Expression     	UnaryExpression		= "not" Expression        	VariableReference		= identifier			BinaryOp		= ArithmeticOp		| LogicalOp		| RelationalOp	ArithmeticOp		= "*"		| "/"		| "mod"		| "+"		| "-"        	LogicalOp		= "and"		| "or"        	RelationalOp		= "="		| "<"		| ">"	literalString		= "\"" (~"\"" any | "\"\"")* "\""	identifier		= simpleIdentifier		| extendedKeywordIdentifier	simpleIdentifier 		= ~ keyword letter alnum*	extendedKeywordIdentifier		= keyword alnum+			keyword		= "sadness"		| "reasons"		| "do"		| "true"		| "false"		| "integer"		| "boolean"		| "string"		| "writeNewLine"		| "write"		| "isa"		| "sorrows"		| "disfunction"		| "if"		| "then"		| "else"		| "sob"		| "while"		| "mod"		| "not"		| "and"		| "or"    	space += comment    	comment		= ":\\" (~"/:" any)* "/:"   	literalInteger  (a number)		=  "-"?digit+       	literalBoolean		= "true"		| "false"}'! !TestCase subclass: #SADParserTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SAD-Parser'!!SADParserTestCase methodsFor: 'running' stamp: 'jws 11/16/2025 19:26'!testArithmetic	| ast |	ast := SADParser parse: self arithmeticProgram.! !!SADParserTestCase methodsFor: 'running' stamp: 'jws 11/18/2025 17:55'!testFactorial	| ast |	ast := SADParser parse: self factorialProgram.! !!SADParserTestCase methodsFor: 'running' stamp: 'jws 11/18/2025 17:55'!testLogical	| ast |	ast := SADParser parse: self logicalProgram.! !!SADParserTestCase methodsFor: 'running' stamp: 'jws 11/18/2025 16:59'!testNano	| ast |	ast := SADParser parse: self nanoProgram.	self assert: ast variables isEmpty.	self assert: ast methods isEmpty.! !!SADParserTestCase methodsFor: 'running' stamp: 'jws 11/18/2025 17:55'!testProcedure	| ast |	ast := SADParser parse: self procedureProgram.! !!SADParserTestCase methodsFor: 'running' stamp: 'jws 11/16/2025 19:26'!testVariables	| ast |	ast := SADParser parse: self variablesProgram.	self 		assert: 3		equals: ast variables size.	self 		assert: 'count'		equals: ast variables first name.	self		assert: 'shouldI'		equals: ast variables second name.	self 		assert: 'message'		equals: ast variables third name.	self assert: ast methods isEmpty.! !!SADParserTestCase methodsFor: 'accessing' stamp: 'jws 11/16/2025 18:05'!arithmeticProgram	^'sadness 	reasons		count isa integer		n isa integer	do		:-(			count <- 9			n <- count + 1			count <- (((n +12) / (3 * 4)) - 3) mod 4		)-:'! !!SADParserTestCase methodsFor: 'accessing' stamp: 'jws 11/16/2025 19:29'!factorialProgram	^'sadness 	reasons		fact5 isa integer	sorrows		disfunction factorial(n isa integer) isa integer		do			if n = 0 then				factorial <- 1			else				factorial <- n * factorial(n - 1)	do		:-(			fact5 <- factorial(5)			writeString "factorial 5 is "			writeInteger fact5			writeNewLine		)-:'! !!SADParserTestCase methodsFor: 'accessing' stamp: 'jws 11/18/2025 17:04'!logicalProgram	^'sadness 	reasons		count isa integer		answer isa boolean	do		:-(			if true and not (3 = count) then				answer <- (count > 9) or (2 < count)		)-:'! !!SADParserTestCase methodsFor: 'accessing' stamp: 'jws 11/16/2025 17:13'!nanoProgram	^'sadness do writeNewLine'! !!SADParserTestCase methodsFor: 'accessing' stamp: 'jws 11/18/2025 17:21'!procedureProgram	^'sadnesssorrows	sob countdown()	reasons		count isa integer	do	:-(		count <- 10		while count > 0 do			:-(				writeInteger count				writeNewLine				count <- count - 1			)-:		writeString "BLASTOFF!!"	)-:do	countdown()'					! !!SADParserTestCase methodsFor: 'accessing' stamp: 'jws 11/16/2025 17:36'!variablesProgram	^'sadness 	reasons		count isa integer		shouldI isa boolean		message isa string	do		writeNewLine'! !OhmSemanticAction subclass: #SADSemantics	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SAD-Parser'!!SADSemantics methodsFor: 'utility' stamp: 'jws 11/16/2025 20:09'!unescapeString: aString	| inStream outStream |	inStream := aString readStream.	outStream := WriteStream on: (String new: aString size).	[inStream atEnd]		whileFalse:			[| nextChar |			nextChar := inStream next.			nextChar = $" ifTrue: [inStream next].			outStream nextPut: nextChar].	^outStream contents! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 20:03'!ArgumentList: aProductionwith: openParenwith: argument1with: commawith: restOfArgumentswith: closeParen	| firstArgument arguments |	firstArgument := self value: argument1.	firstArgument isNil 		ifTrue: 			[^SADArgumentList				arguments: #()				range: (aProduction interval start -> aProduction interval end)].	arguments := (self value: restOfArguments) 		addFirst: firstArgument;		yourself.	^SADArgumentList				arguments: arguments				range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 19:20'!ArithmeticOp: aProductionwith: opSymbol	^SADArithmeticOp		symbol: (self value: opSymbol) asSymbol		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 19:04'!Assignment: aProductionwith: variablewith: assignOpwith: expression	^SADAssignment		identifier: (self value: variable)		expression: (self value: expression)		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 19:16'!BinaryExpression: aProductionwith: arg1with: opwith: arg2	^SADBinaryExpression		arg1: (self value: arg1)		arg2: (self value: arg2)		op: (self value: op)		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 19:16'!BinaryOp: aProductionwith: op	^self value: op! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 19:24'!BlockStatement: aProductionwith: openBlockwith: statementswith: closeBlock	^SADBlockStatement		statements: (self value: statements)		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 19:04'!Expression: aProductionwith: expression	^self value: expression! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 20:23'!Function: aProductionwith: disfunctionwith: identifierwith: parameterswith: isawith: returnTypewith: methodBody	^SADFunction		identifier: (identifier interval contents)		parameters: (self value: parameters)		returnType: (self value: returnType)		methodBody: (self value: methodBody)		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 20:00'!FunctionCall: aProductionwith: identifierwith: arguments	^SADFunctionCall		identifier: (self value: identifier)		arguments: (self value: arguments)		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 19:22'!GroupExpression: aProductionwith: openParenwith: expressionwith: closeParen	^SADGroupExpression		expression: (self value: expression)		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 20:07'!IOStatement: aProductionwith: writeSymbolwith: expression	^SADIOStatement		writeSymbol: (self value: writeSymbol) asSymbol		expression: (self value: expression)		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 17:34'!IOWriteLineStatement: aProductionwith: writeNewLine	^SADIOWriteNewLineStatement new		range: (aProduction interval start -> aProduction interval end);		yourself! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 19:55'!IfThenElseStatement: aProductionwith: ifwith: booleanExpressionwith: thenwith: trueStatementwith: elsewith: falseStatement	^SADIfThenElseStatement		expression: (self value: booleanExpression)		trueStatement: (self value: trueStatement)		falseStatement: (self value: falseStatement)		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/18/2025 17:06'!IfThenStatement: aProductionwith: ifwith: expressionwith: thenwith: statement	^SADIfThenStatement		expression: (self value: expression)		trueStatement: (self value: statement)		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/18/2025 17:13'!LogicalOp: aProductionwith: op	^SADLogicalOp		symbol: (self value: op) asSymbol		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 19:33'!Method: aProductionwith: method	^self value: method! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 19:49'!MethodBody: aProductionwith: variableswith: dowith: statement	^SADMethodBody		variables: (self value: variables)		statement: (self value: statement)		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 19:33'!Methods: aProductionwith: methodswith: methodList	^SADMethods		methods: (self value: methodList)		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 17:09'!NotExpression: aProductionwith: arg1with: arg2	self halt! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 19:46'!ParameterList: aProductionwith: openParenwith: parameter1with: commawith: restOfParameterswith: closeParen	| firstParameter parameters |	firstParameter := self value: parameter1.	firstParameter isNil 		ifTrue: 			[^SADParameterList				parameters: #()				range: (aProduction interval start -> aProduction interval end)].	parameters := (self value: restOfParameters) 		addFirst: firstParameter;		yourself.	^SADParameterList				parameters: parameters				range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/18/2025 17:23'!Procedure: aProductionwith: sobwith: identifierwith: parameterListwith: methodBody	^SADProcedure		identifier: (self value: identifier)		parameters: (self value: parameterList)		methodBody: (self value: methodBody)		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/18/2025 17:26'!ProcedureCall: aProductionwith: identifierwith: arguments	^SADProcedureCall		identifier: (self value: identifier)		arguments: (self value: arguments)		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 17:33'!Program: aProductionwith: sadnesswith: variableswith: methodswith: dowith: statement	^SADProgram		variables: (self value: variables)		methods: (self value: methods)		body: (self value: statement)		range: (aProduction interval start -> aProduction interval end)	! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 19:56'!RelationalOp: aProductionwith: opSymbol	^SADRelationalOp		symbol: (self value: opSymbol) asSymbol		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 17:22'!Statement: aProductionwith: aStatement	^self value: aStatement! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 17:56'!Type: aProductionwith: typeName	| type |	type := SADType perform: (self value: typeName) asSymbol.	^SADTypeNode		type: type		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/18/2025 17:11'!UnaryExpression: aProductionwith: opwith: expression	^SADUnaryExpression		op: (self value: op) asSymbol		expression: (self value: expression)		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 17:51'!Variable: aProductionwith: identifierwith: isawith: type	^SADVariableDeclaration 		type: (self value: type)		name: (self value: identifier)		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/19/2025 18:56'!VariableReference: aProductionwith: identifier	^SADVariableReference 		name: (self value: identifier)		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 17:57'!Variables: aProductionwith: variableswith: variableList	^SADVariables		variables: (self value: variableList)		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/18/2025 17:25'!WhileStatement: aProductionwith: whilewith: expressionwith: dowith: statement	^SADWhileStatement		expression: (self value: expression)		statement: (self value: statement)		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 17:09'!comment: aProductionwith: arg1with: arg2with: arg3	self halt! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 17:09'!extendedKeywordIdentifier: aProductionwith: arg1with: arg2	self halt! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 17:57'!identifier: aProductionwith: identifier	^aProduction interval contents! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 17:09'!keyword: aProductionwith: arg1	self halt! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/18/2025 17:08'!literalBoolean: aProductionwith: boolean	^SADliteralBoolean		value: ((self value: boolean) = 'true')		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 19:11'!literalInteger: aProductionwith: signwith: int	| aValue |	aValue := int interval contents asInteger.	(sign interval contents = '-')		ifTrue: [aValue := aValue negated].	^SADliteralInteger		value: aValue		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 20:15'!literalString: aProductionwith: openQuotewith: escapedStringwith: closeQuote	^SADliteralString 		value: (self unescapeString: (escapedString interval contents))		range: (aProduction interval start -> aProduction interval end)! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 17:09'!simpleIdentifier: aProductionwith: arg1with: arg2	self halt! !!SADSemantics methodsFor: 'semantic actions' stamp: 'jws 11/16/2025 17:09'!space: aProductionwith: arg1	self halt! !Object subclass: #SemanticsCreator	instanceVariableNames: 'grammar baseName'	classVariableNames: ''	poolDictionaries: ''	category: 'SAD-Parser'!!SemanticsCreator methodsFor: 'meta' stamp: 'jws 11/16/2025 16:15'!compileActionForRule: aRulein: aClass	| srcStream |	srcStream := WriteStream on: String new.	srcStream 		nextPutAll: aRule ruleName;		nextPutAll: ': aProduction'; cr.	1 to: aRule arity		do: 			[:index |			srcStream				nextPutAll: 'with: arg';				nextPutAll: index printString; cr].	srcStream		cr; tab;		nextPutAll: 'self halt'.	aClass		compile: srcStream contents		classified: 'semantic actions'! !!SemanticsCreator methodsFor: 'meta' stamp: 'jws 11/16/2025 16:19'!declareASTNodeFor: aRule	| nodeClass |	nodeClass := SADASTNode subclass: ('SAD', aRule ruleName) asSymbol	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SAD-ASTNode'.	nodeClass		compile: (self visitingMethodFor: aRule)		classified: 'visiting'! !!SemanticsCreator methodsFor: 'meta' stamp: 'jws 11/16/2025 16:19'!makeASTNodes	self grammar ruleDeclarations		do:			[:each | self declareASTNodeFor: each]! !!SemanticsCreator methodsFor: 'meta' stamp: 'jws 11/16/2025 16:20'!makeSemanticsClass	| semanticsClass |	semanticsClass := OhmSemanticAction		subclass: (self baseName, 'Semantics') asSymbol		instanceVariableNames: ''		classVariableNames: ''		poolDictionaries: ''		category: 'SAD-Parser'.	self grammar ruleDeclarations		do:			[:each | self compileActionForRule: each in: semanticsClass]! !!SemanticsCreator methodsFor: 'meta' stamp: 'jws 11/16/2025 16:20'!visitingMethodFor: aRule	^'accept: aVisitor<n><n><t>^aVisitor visitSAD<1s>: self' 		expandMacrosWith: aRule ruleName! !!SemanticsCreator methodsFor: 'accessing' stamp: 'jws 11/16/2025 16:14'!baseName	^ baseName! !!SemanticsCreator methodsFor: 'accessing' stamp: 'jws 11/16/2025 16:14'!baseName: anObject	baseName := anObject.! !!SemanticsCreator methodsFor: 'accessing' stamp: 'jws 11/16/2025 16:14'!grammar	^ grammar! !!SemanticsCreator methodsFor: 'accessing' stamp: 'jws 11/16/2025 16:14'!grammar: anObject	grammar := anObject.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SemanticsCreator class	instanceVariableNames: ''!!SemanticsCreator class methodsFor: 'instance creation' stamp: 'jws 11/16/2025 16:21'!baseName: aStringgrammar: aGrammar	^self new		baseName: aString;		grammar: aGrammar;		yourself! !