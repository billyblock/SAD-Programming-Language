Object subclass: #SADInterpreter	instanceVariableNames: 'env remaps program'	classVariableNames: ''	poolDictionaries: ''	category: 'SAD-Interpreter'!!SADInterpreter methodsFor: 'initialize-release' stamp: 'jws 11/25/2025 21:19'!initialize	super initialize.	env := SADEnvironment new.	remaps := Dictionary new.	remaps		at: #mod put: #\\;		at: #/ put: #//;		at: #and put: #&;		at: #or put: #|! !!SADInterpreter methodsFor: 'accessing' stamp: 'jws 11/19/2025 12:05'!env	^ env! !!SADInterpreter methodsFor: 'accessing' stamp: 'jws 11/19/2025 12:05'!env: anObject	env := anObject.! !!SADInterpreter methodsFor: 'accessing' stamp: 'jws 11/30/2025 21:24'!program	^program! !!SADInterpreter methodsFor: 'accessing' stamp: 'jws 11/30/2025 21:24'!program: aProgramString	program := aProgramString! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/20/2025 12:09'!visitSADArgumentList: aSADArgumentList 		^aSADArgumentList arguments 		collect: 			[:each | each accept: self]! !!SADInterpreter methodsFor: 'visiting' stamp: 'WB 12/4/2025 16:16'!visitSADArithmeticOp: aSADArithmeticOp 		^remaps		at: aSADArithmeticOp symbol		ifAbsent: [aSADArithmeticOp symbol]! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/19/2025 12:40'!visitSADAssignment: aSADAssignment 		| var expr |	var := self env variableNamed: aSADAssignment identifier.	expr := aSADAssignment expression accept: self.	var set: expr! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/20/2025 12:23'!visitSADBinaryExpression: aSADBinaryExpression 	| arg1 arg2 opSymbol |	arg1 := aSADBinaryExpression arg1 accept: self.	arg2 := aSADBinaryExpression arg2 accept: self.	opSymbol := aSADBinaryExpression op accept: self.	^arg1 perform: opSymbol with: arg2! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/19/2025 12:38'!visitSADBlockStatement: aSADBlockStatement 	aSADBlockStatement statements		do:			[:each | each accept: self]! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/19/2025 12:37'!visitSADFunction: aSADFunction 		self env		declare: aSADFunction identifier		method: aSADFunction! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/20/2025 12:15'!visitSADFunctionCall: aSADFunctionCall 		| func funcName args params returnVar |	args := aSADFunctionCall arguments accept: self.	func := self env methodNamed: aSADFunctionCall identifier.	funcName := func identifier.	self env activate.	returnVar := SADVariable type: (func returnType accept: self).	self env declare: funcName variable: returnVar.	params := func parameters accept: self.	self apply: args to: params.	func methodBody accept: self.	self env deactivate.	^returnVar get.! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/25/2025 12:21'!visitSADGroupExpression: aSADGroupExpression 		^aSADGroupExpression expression accept: self.! !!SADInterpreter methodsFor: 'visiting' stamp: 'WB 12/8/2025 12:04'!visitSADIOStatement: aSADIOStatement 		Transcript show: (aSADIOStatement expression accept: self)! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/19/2025 12:31'!visitSADIOWriteNewLineStatement: aSADIOWriteNewLineStatement 		Transcript cr! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/20/2025 12:20'!visitSADIfThenElseStatement: aSADIfThenElseStatement 		(aSADIfThenElseStatement expression accept: self)		ifTrue: [aSADIfThenElseStatement trueStatement accept: self]		ifFalse: [aSADIfThenElseStatement falseStatement accept: self]! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/25/2025 21:14'!visitSADIfThenStatement: aSADIfThenStatement 		(aSADIfThenStatement expression accept: self)		ifTrue: [aSADIfThenStatement trueStatement accept: self]! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/25/2025 21:20'!visitSADLogicalOp: aSADLogicalOp 	^remaps		at: aSADLogicalOp symbol		ifAbsent: [aSADLogicalOp symbol]! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/20/2025 12:19'!visitSADMethodBody: aSADMethodBody 		aSADMethodBody variables accept: self.	aSADMethodBody statement accept: self.! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/19/2025 12:19'!visitSADMethods: aSADMethods 		aSADMethods methods		do:			[:each | each accept: self]! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/20/2025 12:11'!visitSADParameterList: aSADParameterList 		^aSADParameterList parameters		collect:			[:each | each accept: self]! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/25/2025 12:16'!visitSADProcedure: aSADProcedure 		self env		declare: aSADProcedure identifier		method: aSADProcedure! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/25/2025 12:18'!visitSADProcedureCall: aSADProcedureCall 		| proc procName args params |	args := aSADProcedureCall arguments accept: self.	proc := self env methodNamed: aSADProcedureCall identifier.	procName := proc identifier.	self env activate.	params := proc parameters accept: self.	self apply: args to: params.	proc methodBody accept: self.	self env deactivate.! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/19/2025 12:16'!visitSADProgram: aSADProgram 	aSADProgram variables accept: self.	aSADProgram methods accept: self.	aSADProgram body accept: self.! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/20/2025 12:25'!visitSADRelationalOp: aSADRelationalOp 		^aSADRelationalOp symbol! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/19/2025 12:30'!visitSADTypeNode: aSADTypeNode 		^aSADTypeNode type! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/25/2025 21:15'!visitSADUnaryExpression: aSADUnaryExpression 		^(aSADUnaryExpression expression accept: self) not! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/19/2025 12:49'!visitSADVariableDeclaration: aSADVariableDeclaration 		| var |	var := SADVariable type: (aSADVariableDeclaration type accept: self).	self env declare: aSADVariableDeclaration name variable: var.	^var! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/30/2025 21:29'!visitSADVariableReference: aSADVariableReference 		| var |	var := [self env variableNamed: aSADVariableReference name]		on: SADError		do: 			[:ex | 			self showError: ex astNode: aSADVariableReference. 			ex return: nil].	var isNil ifTrue: [^nil].	^var get! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/19/2025 12:18'!visitSADVariables: aSADVariables 		aSADVariables variables		do:			[:each | each accept: self]! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/25/2025 12:19'!visitSADWhileStatement: aSADWhileStatement 		[aSADWhileStatement expression accept: self]		whileTrue:			[aSADWhileStatement statement accept: self]! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/25/2025 21:14'!visitSADliteralBoolean: aSADliteralBoolean 		^ aSADliteralBoolean value! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/19/2025 12:46'!visitSADliteralInteger: aSADliteralInteger 		^aSADliteralInteger value! !!SADInterpreter methodsFor: 'visiting' stamp: 'jws 11/19/2025 12:22'!visitSADliteralString: aSADliteralString 		^aSADliteralString value! !!SADInterpreter methodsFor: 'utility' stamp: 'jws 11/20/2025 12:17'!apply: args to: params 		| argStream paramStream |	argStream := ReadStream on: args.	paramStream := ReadStream on: params.	[paramStream atEnd]		whileFalse:			[paramStream next set: argStream next]! !!SADInterpreter methodsFor: 'error reporting' stamp: 'jws 11/30/2025 21:30'!errorTextFor: anAst	| errorText |	errorText := self program asText.	errorText		addAttribute: TextColor red		from: anAst range key		to: anAst range value.	^errorText! !!SADInterpreter methodsFor: 'error reporting' stamp: 'jws 11/30/2025 21:26'!showError: anExceptionastNode: anAstNode	StringHolder new		textContents: (self errorTextFor: anAstNode);		openLabel: anException class name! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SADInterpreter class	instanceVariableNames: ''!!SADInterpreter class methodsFor: 'interpreting' stamp: 'jws 11/30/2025 21:24'!interpret: aProgram		| ast interpreter |	ast := SADParser parse: aProgram.	interpreter := self new.	interpreter program: aProgram.	ast accept: interpreter.	^interpreter! !TestCase subclass: #SADInterpreterTestCase	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'SAD-Interpreter'!!SADInterpreterTestCase methodsFor: 'running' stamp: 'WB 12/8/2025 12:05'!testArithmeticProgram	| interpreter |	interpreter := SADInterpreter interpret: self arithmeticProgram.	self halt.! !!SADInterpreterTestCase methodsFor: 'running' stamp: 'jws 11/20/2025 13:02'!testBadVariablesProgram	| interpreter |	interpreter := SADInterpreter interpret: self badVariablesProgram.! !!SADInterpreterTestCase methodsFor: 'running' stamp: 'jws 11/20/2025 13:02'!testFactorialProgram	| interpreter |	interpreter := SADInterpreter interpret: self factorialProgram.! !!SADInterpreterTestCase methodsFor: 'running' stamp: 'jws 11/25/2025 21:13'!testLogicalProgram	| interpreter |	interpreter := SADInterpreter interpret: self logicalProgram.! !!SADInterpreterTestCase methodsFor: 'running' stamp: 'jws 11/19/2025 12:22'!testNanoProgram	| interpreter |	interpreter := SADInterpreter interpret: self nanoProgram.! !!SADInterpreterTestCase methodsFor: 'running' stamp: 'jws 11/25/2025 12:15'!testProcedureProgram	| interpreter |	interpreter := SADInterpreter interpret: self procedureProgram.! !!SADInterpreterTestCase methodsFor: 'running' stamp: 'jws 11/20/2025 13:01'!testVariablesProgram	| interpreter |	interpreter := SADInterpreter interpret: self variablesProgram.	"The following three statments establish the presence of all vars and their type."	(interpreter env variableNamed: 'count') set: 9.	(interpreter env variableNamed: 'message') set: 'vogon poetry'.	(interpreter env variableNamed: 'shouldI') set: false.! !!SADInterpreterTestCase methodsFor: 'accessing' stamp: 'jws 11/25/2025 12:20'!arithmeticProgram	^'sadness 	reasons		count isa integer		n isa integer	do		:-(			count <- 9			n <- count + 1			count <- (((n +12) / (3 * 4)) - 3) mod 4		)-:'! !!SADInterpreterTestCase methodsFor: 'accessing' stamp: 'jws 11/30/2025 21:30'!badVariablesProgram	^'sadness 	reasons		count isa integer		shouldI isa boolean		message isa string	do		writeInteger whoTheHeckAmI'! !!SADInterpreterTestCase methodsFor: 'accessing' stamp: 'jws 11/20/2025 12:27'!factorialProgram	^'sadness 	reasons		fact6 isa integer	sorrows		disfunction factorial(n isa integer) isa integer		do			if n = 0 then				factorial <- 1			else				factorial <- n * factorial(n - 1)	do		:-(			fact6 <- factorial(6)			writeString "factorial 6 is "			writeInteger fact6			writeNewLine		)-:'! !!SADInterpreterTestCase methodsFor: 'accessing' stamp: 'jws 11/25/2025 21:22'!logicalProgram	^'sadness 	reasons		count isa integer		answer isa boolean	do		:-(			count <- 42			if true and not (3 = count) then				answer <- (count > 9) or (2 < count)		)-:'! !!SADInterpreterTestCase methodsFor: 'accessing' stamp: 'jws 11/17/2025 12:47'!nanoProgram	^'sadness do writeString "Hello, class!!"'! !!SADInterpreterTestCase methodsFor: 'accessing' stamp: 'jws 11/25/2025 12:15'!procedureProgram	^'sadnesssorrows	sob countdown()	reasons		count isa integer	do	:-(		count <- 10		while count > 0 do			:-(				writeInteger count				writeNewLine				count <- count - 1			)-:		writeString "BLASTOFF!!"	)-:do	countdown()'					! !!SADInterpreterTestCase methodsFor: 'accessing' stamp: 'jws 11/19/2025 12:23'!variablesProgram	^'sadness 	reasons		count isa integer		shouldI isa boolean		message isa string	do		writeNewLine'! !